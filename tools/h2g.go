//
// Copyright 2020 chuanshenglu@gmail.com
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//
// I'm a lazy, so writing this tool to convert jvmti, jni headers to corresponding C+Go wrappers
// this conversion makes sense only because Go does not support dyn-bond 'virtual' C functions
// may be fixed after CGO supports that feature.
//

// h2g means 'headers-to-go'

package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	s "strings"
)

const (
	dbg_log_me = false
)

// to hold all the macros
var macros map[string]string

// method
type method struct {
	src   string // original C prototype
	comm  string // comments
	name  string
	ret   string // return type
	ptype []string
	pname []string
	varg  bool   // if last argument is var
}

// parsed result from jvmti.h
type jvmtih struct {
	// constants, primarily JVMTI enum definitions, will be converted to Go const
	cons map[string]string
	// APIs provided by jvmtiEnv
	apis []*method
	// callbacks provided via jvmtiEventCallbacks
	cbs []*method
}

func main() {
	macros = make(map[string]string)
	procArgs()
	p := findJvmtiHeader()
	f, e := os.Open(p)
	if e != nil {
		fmt.Println("jvmti header ", p, " does not exist!")
		panic(f)
	}
	j := parseJvmtiH(f)
	if j != nil {
		j.genJvmtiCWrapper("jvmti_wrapper")
		j.genJvmtiGoWrapper("jvmti_wrapper")
	}
	f.Close()
}

func dbg_log_raw(ar ...string) {
	if dbg_log_me {
		for _, a := range ar {
			fmt.Print(a)
		}
	}
}
func dbg_log(ar ...string) {
	dbg_log_raw(ar...)
	if dbg_log_me {
		fmt.Println("")
	}
}

// Generate .h, .c parts of the wrapper
func (j *jvmtih) genJvmtiCWrapper(srcn string) {
	c := make(chan int, 1)
	defer func() {
		for i:=0; i < 3; i++ {
			<-c
		}
	}()
	// generate $srcn.h
	go func() {
		fp := newFilePrinter(srcn + ".h")
		defer fp.close()
		defer func () { c<-1; }()
		fp.println(copyrightHeader(),
		 	"\n\n",
			"// WARNING: this file was generated automatically, please do not modify it directly!\n\n",
			"#ifndef __", srcn, "_H__\n",
			"#define __", srcn, "_H__\n\n",
			"#ifdef __cplusplus\nextern \"C\" {\n#endif\n")
		for _, m := range j.apis {
			proto := j.cwrapperFor(m)
			fp.println("// ", m.src, "\n",
				proto, "\n",
				";\n")
		}
		fp.println("#ifdef __cplusplus\n} // extern \"C\"\n#endif\n",
		"#endif\n")
	}()

	// generate $srcn.c
	go func() {
		fp := newFilePrinter(srcn + ".c")
		defer fp.close()
		defer func() { c<-2; } ()
		fp.println(copyrightHeader(),
			"\n\n",
			"// WARNING: this file was generated automatically, please do not modify it directly!\n\n",
			"#include <jvmti.h>\n")
		for _, m := range j.apis {
			fp.println("// ", m.src)
			proto := j.cwrapperFor(m)
			if m.varg {
				// TODO: not supported for now! write it manually!
				fp.println("// WARNING: variadic args not supported for now, bite me!\n",
					"//", proto, "\n")
				continue
			}
			// supported ones
			fp.println(proto, " {")
			stmt := "  jvmtiEnv* jvmti = (jvmtiEnv*)env;\n"
			stmt = stmt + "  return (int)(*jvmti)->" + m.name + "("
			for i := 0; i < len(m.ptype); i++ {
				// generate convertion
				if i == 0 {
					// jvmtiEnv at index 0 does not require conversion
					stmt = stmt + m.pname[i]
				} else {
					stmt = stmt + "(" + m.ptype[i] + ")" + m.pname[i]
				}
				if i+1 != len(m.ptype) { // not last
					stmt += ","
				}
			}
			fp.println(stmt, ");\n}\n")
		}
	}()

	// generate $srcn.go
	go func() {
		fp := newFilePrinter(srcn + ".go")
		defer fp.close()
		defer func () { c<-3; }()
		fp.println(copyrightHeader(),
			"\n",
			"// WARNING: this file was generated automatically, please do not modify it directly!\n")
		fp.println(`
// #include "wrapper.h"
// #include "jvmti_wrapper.h"
import "C"

import(
	"unsafe"
)

// JvmtiEnv corresponds to jvmtiEnv*
type JvmtiEnv uintptr

func (jvmti JvmtiEnv) asPointer() unsafe.Pointer {
	return unsafe.Pointer(jvmti)
}
`)
		for _,m := range j.apis {
			fp.println("// ", m.src)
			if m.varg {
				// TODO: not supported for now! write it manually!
				fp.println("// WARNING: variadic args not supported for now, bite me!\n")
				continue
			}
			fp.print("func (jvmti JvmtiEnv) ", m.name,"(")
			// supported ones
			for i:=1; i<len(m.pname); i++ {
			  // skip the first 'jvmtiEnv* jvmti'
				if i > 1 {
					fp.print(", ")
				}
				// generate the remaining ones
				fp.print(m.pname[i], " ")
				fp.print(j.map2gotype(m.ptype[i]))
			}
			fp.println(") {")
			// body
			fp.print("\tC.", m.name,"(jvmti.asPointer()")
			for i:=1; i<len(m.pname); i++ {
				fp.print(", ", m.pname[i])
			}
			fp.println(")")
			fp.println("}\n")
		}
	}()
}

//------------- Wrap the print to file facilities ----------
type filePrinter struct {
	fname  string
	f      *os.File
	closed bool
	writer *bufio.Writer
}

func newFilePrinter(fn string) *filePrinter {
	fp := new(filePrinter)
	fp.fname = fn
	fp.closed = false
	f, err := os.Create(fp.fname)
	if err != nil {
		fmt.Println("Failed to create file ", fp.fname)
		panic(err)
	}
	fp.f = f
	fp.writer = bufio.NewWriter(fp.f)
	if fp.writer == nil {
		fmt.Println("Faield to create writer")
		panic(fp)
	}
	return fp
}

func (fp *filePrinter)println(strs ...string) {
	fp.print(strs...)
	dbg_log_raw("\n")
	fp.writer.WriteString("\n")
}

func (fp *filePrinter)print(strs ...string) {
	dbg_log_raw(strs...)
	for _, s := range strs {
		_,err := fp.writer.WriteString(s)
		if err != nil {
			fmt.Println("Cannot write to ", fp.fname, ", content:", s)
			panic(err)
		}
	}
}

func (fp *filePrinter)close() {
	fp.writer.Flush()
	if !fp.closed {
		fp.f.Close()
	}
}
//------------- Wrap the print to file facilities ----------

func (j *jvmtih) cwrapperFor(m *method) (res string) {
	res = j.map2ctype(m.ret) + " " + m.name + "("
	for i := 0; i < len(m.pname); i++ {
		pt := j.map2ctype(m.ptype[i])
		pn := m.pname[i]
		if i > 0 {
			res += ", "
		}
		res += pt + " " + pn
	}
	if m.varg {
		res += ", ..."
	}
	res += ")"
	return res
}

func (j *jvmtih) map2ctype(t string) string {
	c2g := map[string]string{
		"jvmtiError":     "int",
		"jint":           "int",
		"jlong":          "long long",
		"jdouble":        "double",
		"jvmtiEvent":     "int",
		"jvmtiEventMode": "int",
		"jfloat":         "float",
	}
	ct, ok := c2g[t]
	if ok {
		return ct
	}
	// all the other types, just to "void*"
	return "void*"
}

func (j *jvmtih) map2gotype(t string) string {
	c2g := map[string]string{
		"jvmtiError":     "int",
		"jint":           "int",
		"jlong":          "int64",
		"jdouble":        "double",
		"jvmtiEvent":     "int",
		"jvmtiEventMode": "int",
		"jfloat":         "float",
	}
	ct, ok := c2g[t]
	if ok {
		return ct
	}
	// all the other types, just to "void*"
	return "unsafe.Pointer"
}

func (j *jvmtih) genJvmtiGoWrapper(gn string) {
	fcons := gn + "_const.go"
	f, err := os.Create(fcons)
	if err != nil {
		fmt.Println("Failed to create file ", fcons)
		panic(err)
	}
	wr := bufio.NewWriter(f)
	cwr := func(s string) {
		_,err := wr.WriteString(s)
		if err != nil {
			fmt.Println("Cannot write to ", fcons, ", content:", s)
			panic(err)
		}
	}
	prt := func(ar ...string) {
		dbg_log_raw(ar...)
		for _, a := range ar {
			cwr(a)
		}
	}
	prn := func(ar ...string) {
		prt(ar...)
		dbg_log_raw("\n")
		cwr("\n")
	}
	defer f.Close()
	prn(copyrightHeader())
	prn("// WARNING: this file was generated automatically, please do not modify it directly!\n")
	prn("package main\n\n")
	prn("const (\n")
	ks := make([]string, 0, len(j.cons))
	for k,_ := range j.cons {
		ks = append(ks, k)
	}
	sort.Strings(ks)
	for _,k := range ks {
		prn("\t", k, " = ", j.cons[k])
	}
	prn(")\n")
	wr.Flush()
}

// parse jvmti.h to collect required information
// naive pattern matching based quick & dirty impl, fix later.
func parseJvmtiH(f *os.File) (j *jvmtih) {
	j = new(jvmtih)
	j.cons = make(map[string]string)
	rd := bufio.NewReader(f)
	// mode
	skip := false
	for {
		lb, _, err := rd.ReadLine()
		if err != nil {
			break
		}
		ln := s.TrimSpace(string(lb))
		if skip {
			if s.HasPrefix(ln, "#endif") {
				skip = false
			}
			dbg_log("skipped:", ln)
			continue
		}
		// macro
		if s.HasPrefix(ln, "#ifdef") {
			m := s.TrimSpace(ln[6:])
			_, ok := macros[m]
			skip = !ok
		} else if s.HasPrefix(ln, "#ifndef") {
			m := s.TrimSpace(ln[6:])
			_, ok := macros[m]
			skip = ok
		} else if s.HasPrefix(ln, "#define") {
			ln = s.TrimSpace(ln[7:])
			i := s.Index(ln, " ")
			if i != -1 {
				k := ln[0:i]
				v := s.TrimSpace(ln[i+1:])
				macros[k] = v
			} else {
				macros[ln] = ""
			}
		}

		// TODO: parse tokens
		dbg_log(ln)
		// macro guarded, the current policy is pattern based, and fairly naive
		// constants, we just ignore the enclosing type definition
		if s.HasPrefix(ln, "JVMTI_") && s.Contains(ln, "=") {
			ar := s.Split(ln, "=")
			ar[0] = s.TrimSpace(ar[0])
			ar[1] = s.TrimSpace(s.Trim(ar[1], ","))
			j.cons[ar[0]] = ar[1]
		} else if s.HasPrefix(ln, "typedef") && s.Contains(ln, "*jvmtiEvent") {
			// jvmti event handler prototype
			ln = s.TrimSpace(readToEnd(ln, ";", rd))
			ln = ln[s.Index(ln, " ")+1:]
			ln = s.TrimSpace(ln)
			m := parseJNICallTypeDecl(ln)
			j.cbs = append(j.cbs, m)
		} else if s.HasPrefix(ln, "jvmtiError (JNICALL") && s.Contains(ln, "jvmtiEnv* env") {
			// jvmti apis
			ln = readToEnd(ln, ";", rd)
			m := parseJNICallTypeDecl(ln)
			j.apis = append(j.apis, m)
		} else {
			//dbg_log("ignored:", ln)
		}
	}
	return j
}

// parse single line of jvmti api declaration
// e.g. jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);
func parseJNICallTypeDecl(ln string) (m *method) {
	dbg_log("passing method:", ln)
	m = new(method)
	pat := "(\\w+)\\s+\\(JNICALL\\s+\\*(\\S+)\\)\\s*\\((.*)\\);"
	cp, _ := regexp.Compile(pat)
	ln = s.TrimSpace(ln)
	sn := cp.FindStringSubmatch(ln)
	if sn != nil && len(sn) == 4 {
		m.src = ln
		m.ret = sn[1]
		m.name = sn[2]
		ps := s.Split(sn[3], ",")
		for _, p := range ps {
			p = s.TrimSpace(p)
			if s.Contains(p, " ") {
				li := s.LastIndex(p, " ")
				m.ptype = append(m.ptype, s.TrimSpace(p[:li]))
				m.pname = append(m.pname, s.TrimSpace(p[li+1:]))
			} else if p == "..." {
				m.varg = true
			} else if p == "void" {
				// ignore
			} else {
				fmt.Println("Cannot parse arg:", p)
				panic(p)
			}
		}
	} else {
		fmt.Println("Cannot parse API decl: ", ln)
	}
	return m
}

func readToEnd(l1, suf string, r *bufio.Reader) string {
	res := ""
	for {
		res += s.TrimSpace(l1)
		if s.HasSuffix(l1, suf) {
			break
		}
		lb, _, err := r.ReadLine()
		if err != nil {
			break
		}
		l1 = string(lb)
	}
	return res
}

func procArgs() {
	args := os.Args
	for _, ag := range args {
		if s.HasPrefix(ag, "-D") {
			md := ag[2:]
			if s.Contains(ag, "=") {
				sa := s.Split(ag, "=")
				macros[sa[0]] = sa[1]
			} else {
				macros[md] = ""
			}
		}
	}
}

// detect for path of jvmti.h
func findJvmtiHeader() (path string) {
	args := os.Args
	if len(args) > 0 {
		path = args[len(args)-1]
		if s.HasSuffix(path, "jvmti.h") {
			return path
		}
	}
	_, f := os.LookupEnv("JAVA_HOME")
	if !f {
		fmt.Println("JAVA_HOME not set, canonot find a jvmti")
		path=""
	} else {
		path = os.Getenv("JAVA_HOME") + "/include/jvmti.h"
	}
	return path
}

func copyrightHeader() string {
	return `
// Copyright 2020 chuanshenglu@gmail.com
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
`
}